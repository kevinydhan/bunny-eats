import React, { Component } from 'react'
import PropTypes from 'prop-types'

class Board extends Component {
    totalEntities = 0
    remainingEntities = 0

    constructor(props) {
        super(props)
        this.dimensions = props.boardDimensions

        this.state = {
            board: this.generateBoard(),
            playerCoordinates: this.generatePlayerCoordinates()
                .split(',')
                .map((e) => Number(e)),
        }
    }

    /**
     * Generates a sparse matrix with a width and height specified by
     * `this.props.boardDimensions`.
     *
     * @example
     * <Board boardDimensions={{ width: 3, height: 3 }} />
     * this.board = [[0, 1, 0], [0, 0, 1], [0, 1, 0]]
     *
     * @returns {Array<Array<0>>} - Zero matrix
     */
    generateBoard = () => {
        const { width, height } = this.dimensions
        const board = []

        for (let i = 0; i < height; ++i) {
            board.push(Array(width).fill(0))
        }

        const playerCoordinates = this.generatePlayerCoordinates()
        const entityCoordinates = this.generateEntityCoordinates({
            [playerCoordinates]: 1,
        })

        Object.entries(entityCoordinates).forEach(([coord, entityId]) => {
            const [x, y] = coord.split(',')
            board[Number(y)][Number(x)] = entityId
        })

        return board
    }

    generatePlayerCoordinates = () => {
        const { width, height } = this.dimensions
        const x = Math.floor(width / 2)
        const y = Math.floor(height / 2)
        return `${x},${y}`
    }

    /**
     * Generates a map where each key is a comma-separated x- and y-coorindate and each corresponding value is the entity id.
     *
     * @example
     * { '1,1': 1, '2,3': 1, '4,6': 1 }
     *
     * @returns {object} - Map of comma-separated x- and y-coordinates as keys
     * and entity ids as values
     */
    generateEntityCoordinates = (entityMap) => {
        const { width, height } = this.dimensions

        /**
         * References the total number of entities to spawn on the board.
         */
        let numberOfEntities = Math.round(Math.sqrt(width * height))
        this.totalEntities = numberOfEntities
        this.remainingEntities = numberOfEntities
        /**
         * References the coordinate generated by `this.coordinate()`. This is
         * used to help check whether each generated coordinate is a duplicate
         * of the saved coordinates.
         */
        let currentCoordinate

        /**
         * Contains a map where each key is the coordinate and each corresponding value is the entity id.
         *
         * @example
         * { '1,1': 1, '2,3': 1 }
         */
        const entityCoordinates = { ...entityMap }

        while (numberOfEntities) {
            currentCoordinate = this.generateRandomCoordinate()

            if (!entityCoordinates[currentCoordinate]) {
                entityCoordinates[currentCoordinate] = 2
                numberOfEntities--
            }
        }

        return entityCoordinates
    }

    /**
     * Generates a random coordinate within the board's width and height.
     *
     * @example
     * this.generateRandomCoordinate() // '2,3'
     *
     * @returns {string} - Comma-separated x- and y-coordinates
     */
    generateRandomCoordinate = () => {
        const { width, height } = this.dimensions
        const x = Math.floor(Math.random() * width)
        const y = Math.floor(Math.random() * height)
        return `${x},${y}`
    }

    handleKeyPress = (event) => {
        const { width, height } = this.dimensions
        const [x, y] = this.state.playerCoordinates
        const newBoard = this.state.board.map((row) => row.map((col) => col))

        switch (event.key) {
            case 'w':
            case 'ArrowUp':
                console.log('Player moved 1 space up')

                if (y - 1 >= 0) {
                    if (newBoard[y - 1][x] !== 0) {
                        this.remainingEntities -= 1
                        if (!this.remainingEntities) this.props.endGame()
                        console.log(
                            'Remaining entities: ',
                            this.remainingEntities
                        )
                    }
                    newBoard[y - 1][x] = 1
                    newBoard[y][x] = 0
                    this.setState({
                        playerCoordinates: [x, y - 1],
                        board: newBoard,
                    })
                    this.props.incrementTotalSteps()
                }
                break

            case 's':
            case 'ArrowDown':
                console.log('Player moved 1 space down')

                if (y + 1 < width) {
                    if (newBoard[y + 1][x] !== 0) {
                        this.remainingEntities -= 1
                        if (!this.remainingEntities) this.props.endGame()
                        console.log(
                            'Remaining entities: ',
                            this.remainingEntities
                        )
                    }
                    newBoard[y + 1][x] = 1
                    newBoard[y][x] = 0
                    this.setState({
                        playerCoordinates: [x, y + 1],
                        board: newBoard,
                    })
                    this.props.incrementTotalSteps()
                }
                break

            case 'a':
            case 'ArrowLeft':
                console.log('Player moved 1 space to the left')

                if (x - 1 >= 0) {
                    if (newBoard[y][x - 1] !== 0) {
                        this.remainingEntities -= 1
                        if (!this.remainingEntities) this.props.endGame()
                        console.log(
                            'Remaining entities: ',
                            this.remainingEntities
                        )
                    }
                    newBoard[y][x - 1] = 1
                    newBoard[y][x] = 0
                    this.setState({
                        playerCoordinates: [x - 1, y],
                        board: newBoard,
                    })
                    this.props.incrementTotalSteps()
                }
                break

            case 'd':
            case 'ArrowRight':
                console.log('Player moved 1 space to the right')

                if (x + 1 < height) {
                    if (newBoard[y][x + 1] !== 0) {
                        this.remainingEntities -= 1
                        if (!this.remainingEntities) this.props.endGame()
                        console.log(
                            'Remaining entities: ',
                            this.remainingEntities
                        )
                    }
                    newBoard[y][x + 1] = 1
                    newBoard[y][x] = 0
                    this.setState({
                        playerCoordinates: [x + 1, y],
                        board: newBoard,
                    })
                    this.props.incrementTotalSteps()
                }
                break
        }
        console.log(this)
    }

    render() {
        const { state, handleKeyPress } = this
        const { board } = state

        return (
            <main
                tabIndex="0"
                onKeyDown={handleKeyPress}
                style={{ outline: 'none' }}
            >
                {board.map((row, i) => {
                    return (
                        <div key={`row-${i}`}>
                            {row.map((col, i) => (
                                <span key={`col-${i}`}>{col}</span>
                            ))}
                        </div>
                    )
                })}
            </main>
        )
    }
}

Board.propTypes = {
    boardDimensions: PropTypes.shape({
        width: PropTypes.number.isRequired,
        height: PropTypes.number.isRequired,
    }),
    incrementTotalSteps: PropTypes.func.isRequired,
    endGame: PropTypes.func.isRequired,
}

export default Board
